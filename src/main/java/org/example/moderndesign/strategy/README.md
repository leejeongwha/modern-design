## Strategy 패턴

- 변화하는 부분을 캡슐화하여 행위를 동적으로 바꾸기 쉽게 해주는 패턴. 즉, 알고리즘을 인터페이스로 정의하고, 이를 구현 클래스들로 분리하여 필요에 따라 런타임에 교체할 수 있게 하는 구조를 의미한다.

## Strategy 패턴을 람다로 구현했을 경우의 장단점

### 장점

- 보일러플레이트 코드 감소 : 각 전략마다 별도의 클래스를 만들 필요가 없다. 전략을 람다 표현식이나 메서드 참조로 정의하여 코드를 간결하고 깔끔하게 유지할 수 있다.
- 향상된 유연성 : 핵심 구조를 변경하지 않고도 전략을 인라인으로 쉽게 정의하거나 수정할 수 있다. 이러한 유연성 덕분에 요구 사항에 맞춰 전략을 즉석에서 생성할 수 있다.
- 가독성 향상 : 과도한 클래스 선언을 제거하여 코드의 가독성과 집중도를 높일 수 있다. 각 람다 표현식이 기능 측면에서 무엇을 나타내는지 즉시 명확하게 알 수 있다.
- 확장성 용이 : 새로운 전략을 추가한다고 해서 더 이상 코드베이스가 새 클래스로 복잡해지지 않는다. 람다 표현식을 추가 하는 것만으로도 쉽게 확장이 가능하다.
- 테스트 간소화 : 다양한 클래스를 인스턴스화하지 않고도 동작을 직접 호출하고 테스트 할 수 있다.

### 단점

- 단일 목적 함수로 제한 : 함수형 프로그래밍은 상태를 가지지 않는, 단일 목적의 작업에 가장 적합하다. 여러 메서드나 복잡한 상태 관리가 필요한 전략에는 기존 클래스 기반 전략이 더 적합하다.
- 디버깅의 어려움 : 람다 표현식은 익명으로 처리되므로 StackTrace 해석이 어렵다. 예외가 발생 시 명명된 클래스에 비해 원인 추적이 힘들 수 있다.
- 의존성 주입의 한계 : 람다 표현식은 자신만의 생성자나 필드가 없기 때문에 직접 주입할 수 있는 방법이 없다. 반드시 외부에 선언된 effectively final 변수를 캡처해서 참조해야 한다. 따라서 결제 서비스가 특정 데이터베이스나 외부 API에 의존한다면 람다로 처리하기 어려울 수 있다.
- 타입 안전성 저하 : 람다 표현식은 런타임에 타입이 결정되므로, 동적 시나리오에서 타입 안전성을 잃을 수 있다. 예를 들어, 결제 수단이 런타임에 결정되는 경우, 적절한 타입 검사가 어려울 수 있다.
