## Decorator 패턴

- 기존 객체의 기능을 변경하거나 확장할 때, 상속(서브클래싱) 대신 객체를 감싸는 방식으로 새로운 기능을 동적으로 추가하는 구조적 디자인 패턴.
- 말 그대로, 원본 객체에 새로운 장식을 덧붙이듯 기능을 더해주는 것이 특징.

```
/**
 * 한 글자씩 읽는 대신, 내부 버퍼에 미리 데이터를 읽어놓아 I/O 성능 향상(시스템 호출 감소)
 * Reader는 줄 단위 읽기 기능이 없음, BufferReader가 추가
 */
try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
}
```

### 구조 요약

- Text 인터페이스: 문자열을 받아 변환하는 format 메서드 정의
- PlainText: 기본 구현. 입력 문자열을 그대로 반환
- TextDecorator: 데코레이터의 공통 기능을 위한 추상 클래스. 내부에 Text 타입을 보관
- AllCapsDecorator: 문자열을 대문자로 변환하는 데코레이터
- SuffixDecorator: 문자열 끝에 접미사를 추가하는 데코레이터

### 주요 특징

- 기존 코드를 수정하지 않고, 객체를 감싸는 데코레이터 객체를 추가함으로써 기능을 동적으로 확장.
- 상속보다 훨씬 유연하게 기능을 조합할 수 있으며, 여러 데코레이터를 중첩해 다양한 기능을 조합할 수 있다.
- 단일 책임 원칙(SRP) 및 개방-폐쇄 원칙(OCP) 준수: 각 데코레이터는 하나의 기능만을 담당하므로, 기능 추가·수정 시 기존 코드를 건드릴 필요가 없다.

### 명시적 클래스 방식과 람다 방식 비교

- 명시적 클래스 :
    - 인터페이스와 추상 데코레이터, 구체 데코레이터 클래스를 조합해 동적으로 기능을 확장
- 람다/함수형 방식 :
    - Function 인터페이스와 함수 합성을 이용해, 별도 클래스를 만들지 않고도 데코레이터 패턴의 효과를 간결하게 구현
